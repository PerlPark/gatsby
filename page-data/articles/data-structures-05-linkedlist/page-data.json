{"componentChunkName":"component---src-templates-article-js","path":"/articles/data-structures-05-linkedlist/","webpackCompilationHash":"647084cfce12e047c402","result":{"data":{"markdownRemark":{"html":"<p>올해 초 부터 프로그래밍을 공부 중이다. 상반기에는 열심히 공부하다가, 지금은 진도가 매우 더디지만..<br>\n그 중에 재밌게 공부하고 있는 자료구조에서 연결 리스트 배운 걸 응용하여 프로그램을 짜 봤다.  </p>\n<p>자료구조 중 연결리스트는 최대 메모리 공간을 미리 정하지 않고, <span style=\"color:red\">메모리를 동적할당</span>하여 프로그램 실행 중에 <span style=\"color:red\">노드(Node)가 추가될 때 마다 공간을 확보</span>한다. 노드(Node)는 데이터와 다음 데이터를 가르키는 링크의 한 덩어리로, <span style=\"color:red\">메모리 공간에서의 물리적인 순서와 상관없이 데이터 간의 논리적인 순서</span>를 만들 수 있는 장점이 있다.  </p>\n<figure style=\"text-align:center;\">\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 834px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 15.070643642072213%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAk0lEQVQI152NuQ6DMBBE+f+aDvEjScknRIgCpUlikSbY2Bw+MC9LlzrTzM6h2YJfHBked1BPGAb+QdH3PV3XcXJKCb96YvgQN0UIEe83UnyLp0XvxOjkVtIN5Hyw74ltC6KNsKKoqoqyLKnrmmWZ0dqxLjcJG4yxTJMh+IbZtVgbxX9JfpGulpEsD1fG8ey1OHvlC+5b5JBHfTIqAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"data structures 05 linkedlist 1\" title=\"data structures 05 linkedlist 1\" src=\"/static/59e43c434e2e84475fa9045b7dde8501/1d25d/data-structures-05-linkedlist_1.png\" srcset=\"/static/59e43c434e2e84475fa9045b7dde8501/de370/data-structures-05-linkedlist_1.png 209w,\n/static/59e43c434e2e84475fa9045b7dde8501/d854d/data-structures-05-linkedlist_1.png 417w,\n/static/59e43c434e2e84475fa9045b7dde8501/1d25d/data-structures-05-linkedlist_1.png 834w,\n/static/59e43c434e2e84475fa9045b7dde8501/be1b7/data-structures-05-linkedlist_1.png 1251w,\n/static/59e43c434e2e84475fa9045b7dde8501/9870e/data-structures-05-linkedlist_1.png 1274w\" sizes=\"(max-width: 834px) 100vw, 834px\" loading=\"lazy\">\n    </span>  \n<figcaption style=\"text-align:center;font-size: 0.9em;\">head&#xAC00; &#xAC00;&#xB974;&#xD0A4;&#xB294; &#xB178;&#xB4DC;&#xC5D0;&#xC11C; &#xC2DC;&#xC791;, &#xB9C1;&#xD06C;&#xB97C; &#xD1B5;&#xD574; &#xB370;&#xC774;&#xD130;&#xAC00; &#xB17C;&#xB9AC;&#xC801;&#xC778; &#xC21C;&#xC11C;&#xB85C; &#xC5F0;&#xACB0;&#xB41C;&#xB2E4;.</figcaption>\n</figure>\n<figure style=\"text-align:center;\">\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 456px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 152.85087719298247%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAABYlAAAWJQFJUiTwAAAETklEQVRIx41Wa3PaSBD0//8bV/lwVUnsVOVlx4ADmGDj8yuunG3sxCDeIBB6sSDBpHs4YfkMSVS1pUXa7e3p6RmxJf+7FovFaj6dTmU0GkkYhhgG87aMx59lar5gFMV1TyWO50/2b60Dm0wm0mw29T6fz+Xm5kZqNQtvArEH76VeeyOt5jYOOMQBrq4LgkCMMesBZ7OZDIdDZRhFEZi44jgewF1xxx+lXt+RRmNbhnZBLKuh7xkJQbd+F/JgMNCQg2Aitt2U0bAgvl+WMCiJMzrDmkijGI/HynTrTzT0fQ8jBMs2QLJiJkUJ/AMZOxVouFxPls8AEzDHceT6+lqZ8fT7+zto2MBmV+IoJw8/tsFwDwdWcOBYD7btgbJcC0gghsoT4zjGYls3EjCa5WTQ/yCz6T7GiWZ/sViG7Hne70Pu9/sI18cIcEgTYAWEeyyeW0JSztQ23MOQuW4tQ4bJOQF5chgGmhTX7SLL+5gf4L4H0GOsfdRwIyDDpYZcxHAsqy6dTg9zDwnJSO1hB0zfyiQ8gl9bKgl1V8AEhPdkTmbLrBnMY80k7Ii5iwrJIuSMzOMc7mV4sqFASzf8xzANlr6mUwNmd/BeDaMO5rfQtAjrlKFfEb/PJNm2Yki9kovzpX5zXWiMCxafwCaLjGag2y5CziHTeZlHOU0OjU0yK8DLy0s5Pz+Xcrkst7e3qh81qdct+O9f+O4QRxUxDuXm+qXc373SuchnrZh2uyO9XldLVQHpOepFEM4fE8QmgXIKM7KYZwHMCkGG/SwYF/DsAOZGpSDL3NvtdnX/Wh8+NgkjrdYVBL+DZlUw+YrsFjH/gq5TwO9TPZjser3esjkkAGkg6siXQRAiuwt40cfpEQ7wwJg+zCDb+2BcwftYZVrLMAFkX6OurBI8laurr/L9+4P6cOzsyknlL9TzS4Rchs4/pFqtwg2dzYC8sycSmEzpy9ksxgZbNQz8HNhlof0RQu1ruK1Wa7OG6Vput9tafo7jYl6TbicP+xzBl0VEcLry4FrAdLfhAjJkx16WlqvdhhqOhh9x3xPfK+HzUFXbMORnHTsNaFmW+orPLi4uUNtV/aYM7feqYau5oxpSWyZl5cNfhUwd2ePI1JgZNqCVeTkA5aHhAX6fYE2kPTOOoz/rhwzF81z9unU7del182hbZUiAWoaGSfvivmeACRhfJDagJ6mn6wZqm0n4CaDvAPoBXjxWbY2Z6Fp2nLWA9B/rmpoQsFZ7gPC2Avrennz79rc0rNcI+xjPBwpIEk+SkvZgWkNahm1sYtgje7AMajg8BFOG/vjPgV19o23SGtK0PN3zfMwbWsuBXwFwCfV8tgIkuyeACRh9x7qkhswuQ6YPbdvBWx9guyi71/DiW0RQ0a9eFM02A9ICBKMPE2Pzu2xZLYB7ANqV039eSLNBHx7heVPbH6XZaOy0hvw2J5cx+L9jcpiVMPLQsaJfw3Tb+wm9KkXQFecz2QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"data structures 05 linkedlist 2\" title=\"data structures 05 linkedlist 2\" src=\"/static/02d68147ee1c89c53d5ac68aecb53042/3abf2/data-structures-05-linkedlist_2.png\" srcset=\"/static/02d68147ee1c89c53d5ac68aecb53042/de370/data-structures-05-linkedlist_2.png 209w,\n/static/02d68147ee1c89c53d5ac68aecb53042/d854d/data-structures-05-linkedlist_2.png 417w,\n/static/02d68147ee1c89c53d5ac68aecb53042/3abf2/data-structures-05-linkedlist_2.png 456w\" sizes=\"(max-width: 456px) 100vw, 456px\" loading=\"lazy\">\n    </span>  \n<figcaption style=\"text-align:center;font-size: 0.9em;\">\n    &#xBA54;&#xBAA8;&#xB9AC; &#xACF5;&#xAC04;&#xC5D0;&#xC11C;&#xC758; &#xBAA8;&#xC2B5; &#xC608;&#xC2DC;<br>\n    <cite>&#xC0BD;&#xD654; &#xCC38;&#xACE0;: &#xC790;&#xB8CC;&#xAD6C;&#xC870;, &#xC815;&#xAD11;&#xC2DD; &#xC800;</cite>\n</figcaption>\n</figure>\n<p>설명은 이쯤하고, 그래서 프로그램은 이렇다.<br>\n강의 내용을 응용하여 연결 리스트의 마지막에 데이터 삽입/삭제, 특정 위치에 삽입/삭제가 가능하다.  </p>\n<div class=\"attachments\"><a href=\"http://blog.naver.com/jinjoo_park/221386894502\" target=\"_blank\">exec &#xB2E4;&#xC6B4;&#xB85C;&#xB4DC; _ Naverblog</a></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 834px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 74.96823379923761%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACuElEQVQ4y6WT207bQBCGQ/siRUAJaRDXjdS+Qp6rT1AVtRK4hDZQCBCcEyaO8dmJEzsh5yMHQSXoBVWuMN3p7AZCRFWpUi39mtn17pd/ZhyfD59OOvPCcoS35Wb3dcFyQqblhjStEDJNB6PNpCj5kCQZLD86MkO6XmR7rlsPHR+335SK1Wnfw6PGVpfLDg+GlrlVxX0iZ+Mkl4kxiShDThFDSRFV4okmJVg05CTbc/Ki12/ZoMupT2Pg3tYyV80nQMlEPF2MgiFugJnbBFuNgZ6NgiltgoXKy1vgWvtQKfCTuhs0JZCEL+tj4G70PVdBoJ77dqsIUaJmN0heiZGKnSQFdYfY+h7GXVIy4qTXkslJRyX9tsI0aCvej+8OaEfbkTEwHV/hurUcOBbv1ZwMlBFeLiSg5h5Aydxna4SBg3nzOAuNyiF7Vy8fQKsq3p33dMim1x8dZniOO+uogDCvVaUXBGjipUZZgDpe7NRzMOgogG6g35IBXbJ4n99dXRRBlbYegYepCHeKFyp2yqMACu02JAaionl/AtJ/Ary+LGHJE0Ah8Zk766q0DK9dE6FdG4FYXhX/AVh8AkyucadYDvbNq5bSOEke+zMqm/aJ/gArtz0qe1L9vwHPuhrtl0cvU2cPpY7Klhh0sg0P53DvTyBOefWkTXuYvEUowR4SdEhwmgQHRdApyxFwnwuEnqPvcM+7urDpUB4/m2wqsnZ5YlLgrwYOpYnldqlDdNZDVzQyZ+io35ThfGDABZ6nOu1p5Oa6AoYS+zoGJuMry06eB1OJ3eS13aEhbw8tdWdYsvihW0gMnQm5heSwbFOlmFw7+bOKJoR0ZPzXm1rwzwaXlgLhYHCeaXHRz2IgMBdeWJgNB5jmmOja75951PxM+BWeezk3HUTWM59bSjMoW/h8z/9DUx8/vPP9Bmx5DbQlLfyBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"data structures 05 linkedlist 3\" title=\"data structures 05 linkedlist 3\" src=\"/static/bebd45741d8f06ab7eb9a19fe93aec15/1d25d/data-structures-05-linkedlist_3.png\" srcset=\"/static/bebd45741d8f06ab7eb9a19fe93aec15/de370/data-structures-05-linkedlist_3.png 209w,\n/static/bebd45741d8f06ab7eb9a19fe93aec15/d854d/data-structures-05-linkedlist_3.png 417w,\n/static/bebd45741d8f06ab7eb9a19fe93aec15/1d25d/data-structures-05-linkedlist_3.png 834w,\n/static/bebd45741d8f06ab7eb9a19fe93aec15/be1b7/data-structures-05-linkedlist_3.png 1251w,\n/static/bebd45741d8f06ab7eb9a19fe93aec15/ec011/data-structures-05-linkedlist_3.png 1574w\" sizes=\"(max-width: 834px) 100vw, 834px\" loading=\"lazy\">\n    </span>  \n&#xC774;&#xD574;&#xD558;&#xAE30; &#xC26C;&#xC6B4; &#xBC30;&#xC5F4;/&#xC2A4;&#xD0DD;/&#xD050;&#xC5D0;&#xC11C; &#xAC11;&#xC790;&#xAE30; &#xB0B4;&#xC6A9;&#xC774; &#xBCF5;&#xC7A1;&#xD574;&#xC84C;&#xC9C0;&#xB9CC;, &#xC774;&#xAC70; &#xB9CC;&#xB4E4;&#xBA74;&#xC11C; &#xCC28;&#xCC28; &#xC774;&#xD574;&#xD574; &#xB098;&#xAC14;&#xB2E4;.  \n&#xC5B4;&#xB824;&#xC6E0;&#xC9C0;&#xB9CC; &#xC740;&#xADFC;&#xD788; &#xC7AC;&#xBC0C;&#xC5C8;&#xB2E4;. ^^  \n  \n&#xC544;&#xB798;&#xB294; &#xC18C;&#xC2A4;&#xCF54;&#xB4DC;&#xC774;&#xB2E4;. [Mac OS, Xcode&#xC5D0;&#xC11C; C&#xB85C; &#xAC1C;&#xBC1C;]\n<pre><code class=\"language-cpp\">//\n//  main.c\n//  DataStructures_05_02\n//\n//  Created by Jinjoo on 2018. 10. 27..\n//  Copyright © 2018년 Jinjoo. All rights reserved.\n//\n\n#include &#x3C;stdio.h>\n#include &#x3C;stdlib.h> //동적할당을 위해 필요\n\n/* 단순 연결 리스트의 노드 구조 정의 */\ntypedef struct ListNode {\n    int data;\n    struct ListNode* link;\n}listNode;\n\n/* 리스트의 헤드(first) 노드 구조 정의 */ \ntypedef struct {\n    listNode* head;\n}headNode;\n\nheadNode* createLinkedList_h(void){ //헤드 노드를 하나 생성하여 반환\n    headNode* H; //헤드 노드를 가르키는 포인터 변수 H 생성\n    H = (headNode*)malloc(sizeof(headNode)); //포인터 변수 사이즈 크기의 메모리 영역을 할당받고, 그 메모리 영역의 주소를 반환\n    H->head = NULL; //가르킬 노드가 없으니 NULL값 저장\n    return H;\n}\n\n\n/* 연결 리스트의 노드 삽입 */\nvoid addNode(headNode* H, int x){\n    listNode* newNode;\n    listNode* lastNode;\n    \n    newNode = (listNode*)malloc(sizeof(listNode));\n    newNode->data = x; //데이터로 x입력받음\n    newNode->link = NULL; //연결 리스트 마지막에 추가되는 노드이므로 link는 NULL을 가르킴\n    if(H->head==NULL){ //헤드 노드가 NULL을 가리키고 있으면\n        H->head = newNode; //헤드 노드에 새로 생성한 노드를 연결함\n        return;\n    }//헤드 노드가 NULL상태가 아니면,\n    lastNode = H->head;\n    while(lastNode->link != NULL)lastNode = lastNode->link; //NULL을 가리키고 있는 마지막 노드를 찾아\n    lastNode->link = newNode; //새로운 노드를 연결한다\n}\n\n/* 연결 리스트의 노드 삭제 */\nvoid deleteNode(headNode* H){\n    listNode* prevNode;\n    listNode* delNode;\n    if(H->head->link == NULL){\n        free(H->head);\n        H->head = NULL;\n        return;\n    }else{\n        prevNode = H->head;\n        delNode = H->head->link;\n        while(delNode->link != NULL){ //link가 NULL값을 가진, 마지막 노드를 찾아\n            prevNode = delNode;\n            delNode = delNode->link;\n        }\n        free(delNode); //해제 한다\n        prevNode->link = NULL; //그리고 그 앞에 있던 노드의 link를 NULL값으로 변경한다.\n    }\n}\n\n/* 연결 리스트의 특정 노드 다음에 삽입 */\nvoid additNode(headNode* H, int itdata, int *x){\n    listNode* prevNode;\n    prevNode = H->head;\n    while(prevNode->data != itdata)\n    {\n        if(prevNode->link == NULL){\n            printf(\"[선택한 데이터를 찾을 수 없어, 추가하지 못했습니다.]\\n\\n\");\n            return;\n        }\n        else{\n            prevNode = prevNode->link;\n        }\n    }\n    printf(\"[선택한 데이터를 찾았습니다! 이 뒤에 새로운 데이터를 추가합니다.]\\n\\n\");\n    *x+=100;\n    listNode* newNode;\n    newNode = (listNode*)malloc(sizeof(listNode));\n    newNode->data = *x;\n    newNode->link = NULL;\n    \n    newNode->link = prevNode->link;\n    prevNode->link = newNode;\n    return;\n}\n\n/* 연결 리스트의 특정 노드 삭제 */\nvoid deleteitNode(headNode* H, int itdata){\n    listNode* delNode;\n    listNode* prevNode;\n    \n    if(H->head->link == NULL &#x26;&#x26; H->head->data == itdata){\n        free(H->head);\n        H->head = NULL;\n        return;\n    }else if(H->head->link != NULL &#x26;&#x26; H->head->data == itdata){\n        delNode = H->head;\n        H->head = H->head->link;\n        free(delNode);\n        return;\n    }else{\n        delNode = H->head;\n        prevNode = delNode;\n        while(delNode->data != itdata)\n        {\n            if(delNode->link == NULL &#x26;&#x26; delNode->data != itdata){\n                printf(\"[선택한 데이터를 찾을 수 없어, 삭제하지 못했습니다.]\\n\\n\");\n                return;\n            }\n            else{\n                prevNode = delNode;\n                delNode = delNode->link;\n            }\n        }\n        printf(\"[선택한 데이터를 찾았습니다! 해당 데이터를 삭제합니다.]\\n\\n\");\n        prevNode->link = delNode->link;\n        free(delNode);\n        return;\n    }\n}\n\n/* 연결 리스트 출력 */\nvoid printList(headNode* H){\n    listNode* p;\n    if(H->head == NULL){\n        printf(\"== 연결 리스트: 데이터 없음 ==\\n\\n\");\n    }else{\n        printf(\"== 연결 리스트: \");\n        p = H->head;\n        while(p != NULL){\n            printf(\"%d\", p->data);\n            p = p->link;\n            if(p != NULL){\n                printf(\"->\");\n            }\n        }\n        printf(\" ==\\n\\n\");\n    }\n}\nint main() {\n    headNode* L;\n    L = createLinkedList_h();\n    int select_function=0, nodeData=0, selectNodeData;\n    \n    printf(\"자료구조 5장 실습 : 연결 리스트        developed by Perlpark\\n\");\n    printf(\"============================================================\\n\");\n    printf(\"수행할 동작을 선택해 주세요.\\n※숫자 외 문자를 입력하면 오류가 나며, 해결 방법이 없습니다.\\n\");\n    printf(\"============================================================\\n\");\n    printf(\"0:데이터 삽입  |  1:데이터 삭제  |  2:특정 위치에 데이터 삽입  |  3:특정 데이터 삭제  |  9:종료\\n\\n\");\n    \n    while(select_function != 9){\n        printf(\"동작 선택: \");\n        scanf(\"%d\", &#x26;select_function);\n        switch (select_function) {\n            case 0:\n                nodeData+=100;\n                addNode(L, nodeData);\n                printf(\"\\n[연결 리스트의 마지막에 데이터를 추가했습니다.]\\n\\n\");\n                printList(L);\n                break;\n            case 1:\n                if(L->head == NULL){\n                    printf(\"\\n[데이터가 존재하지 않습니다. 데이터 삽입부터 해주세요.]\\n\\n\");\n                }else{\n                    deleteNode(L);\n                    printf(\"\\n[연결 리스트의 마지막 데이터를 삭제했습니다.]\\n\\n\");\n                    printList(L);\n                }\n                break;\n            case 2:\n                if(L->head == NULL){\n                    printf(\"\\n[데이터가 존재하지 않습니다. 데이터 삽입부터 해주세요.]\\n\\n\");\n                }else{\n                    printf(\"\\n[연결 리스트의 특정 위치에 새로운 데이터를 추가합니다. 어느 데이터 뒤에 추가할까요?]\\n\\n\");\n                    printf(\"데이터 선택: \");\n                    scanf(\"%d\", &#x26;selectNodeData);\n                    printf(\"\\n\");\n                    additNode(L, selectNodeData, &#x26;nodeData);\n                    printList(L);\n                }\n                break;\n            case 3:\n                if(L->head == NULL){\n                    printf(\"\\n[데이터가 존재하지 않습니다. 데이터 삽입부터 해주세요.]\\n\\n\");\n                }else{\n                    printf(\"\\n[연결 리스트에서 특정 데이터를 찾아 삭제합니다. 어떤 데이터를 삭제할까요?]\\n\\n\");\n                    printf(\"데이터 선택: \");\n                    scanf(\"%d\", &#x26;selectNodeData);\n                    printf(\"\\n\");\n                    deleteitNode(L, selectNodeData);\n                    printList(L);\n                }\n                break;\n            case 9:\n                printf(\"\\n[종료합니다.]\\n\");\n                break;\n            default:\n                printf(\"\\n[유효하지 않은 명령입니다. 다른 번호를 입력해주세요.]\\n\");\n                break;\n        }\n    }\n}\n</code></pre>\n<p>** 참고 블로그<br>\n이해가 안되거나 오류가 생겨서 막혔던 부분은 아래 블로그를 참고했다.<br>\n<a href=\"https://blog.naver.com/simonmatthew/221304432762\" target=\"_blank\">https://blog.naver.com/simonmatthew/221304432762</a><br>\n<a href=\"https://massy2002.blog.me/12433974\" target=\"_blank\">https://massy2002.blog.me/12433974</a></p>","frontmatter":{"title":"자료구조 5강 연결 리스트 실습","date":"October 28, 2018"},"timeToRead":4}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/articles/data-structures-05-linkedlist/","previous":{"frontmatter":{"title":"jekyll 블로그 로컬에서 확인하기","slug":"/articles/jekyll-localhost/"}},"next":{"frontmatter":{"title":"2018 SW제품 시장성테스트 평가단에 지원했습니다","slug":"/articles/2018-sw-prosumer/"}}}}}